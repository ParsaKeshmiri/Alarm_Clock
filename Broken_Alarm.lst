0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 440 Hz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P3.7 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 24000000 ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 544*2    ; Tone changed to C#
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/(TIMER0_RATE))))
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/(TIMER2_RATE))))
0000             15   
0000             16   ;TODO if time: Add power button
0000             17   AMPM_SET           equ P0.0 ; switch between AM and PM
0000             18   CA_SWITCH     equ P0.1 ; switches buttons between controlling clock and alarm
0000             19   ALARM_OFF     equ P0.3 ; turns off alarm sound
0000             20   SOUND_OUT     equ P2.1
0000             21   SECONDS       equ P2.3 ; adjust seconds
0000             22   MINUTES            equ P2.6 ; adjust minutes
0000             23   HOURS              equ P3.2 ; adjust hours
0000             24   BOOT_BUTTON   equ P3.7
0000             25   
0000             26   ; Reset vector
0000             27   org 0x0000
0000 0201A0      28       ljmp main
0003             29   
0003             30   ; External interrupt 0 vector (not used in this code)
0003             31   org 0x0003
0003 32          32            reti
0004             33   
0004             34   ; Timer/Counter 0 overflow interrupt vector
000B             35   org 0x000B
000B 020104      36            ljmp Timer0_ISR
000E             37   
000E             38   ; External interrupt 1 vector (not used in this code)
0013             39   org 0x0013
0013 32          40            reti
0014             41   
0014             42   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             43   org 0x001B
001B 32          44            reti
001C             45   
001C             46   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             47   org 0x0023 
0023 32          48            reti
0024             49            
0024             50   ; Timer/Counter 2 overflow interrupt vector
002B             51   org 0x002B
002B 02012D      52            ljmp Timer2_ISR
002E             53   
002E             54   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             55   dseg at 0x30
0030             56   Count1ms:        ds 2 ; Used to determine when half second has passed
0032             57   CurrentHour:     ds 2  
0034             58   CurrentMinute:   ds 2
0036             59   CurrentSecond:   ds 2
0038             60   CurrentAMPM:     ds 1
0039             61   AlarmHour:       ds 2
003B             62   AlarmMinute:     ds 2
003D             63   AlarmSecond:     ds 2
003F             64   AlarmAMPM:       ds 1
0040             65   is_AM: ds 1
002E 414D00      66   AM: db 'AM', 0 
0031 504D00      67   PM: db 'PM', 0
0034             68   
0034             69   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0034             70   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             71   bseg
0000             72   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             73   
0034             74   cseg
0034             75   ; These 'equ' must match the wiring between the microcontroller and the LCD!
0034             76   LCD_RS equ P2.0
0034             77   LCD_RW equ P1.7
0034             78   LCD_E  equ P1.6
0034             79   LCD_D4 equ P1.1
0034             80   LCD_D5 equ P1.0
0034             81   LCD_D6 equ P0.7
0034             82   LCD_D7 equ P0.6
                 84   	$LIST
00E2             86   
00E2             87   ;                     1234567890123456    <- This helps determine the location of the counter
00E2 78783A78    88   Initial_Message:  db 'xx:xx:xx xx', 0 ; hour:minute:second am/pm
     783A7878
     20787800
00EE             89   
00EE             90   ;-----------------------------------;
00EE             91   ; Routine to initialize the timer 0 ;
00EE             92   ;-----------------------------------;
00EE             93   Timer0_Init:
00EE 438E04      94            orl CKCON0, #00000100B ; Timer 0 uses the system clock
00F1 E589        95            mov a, TMOD
00F3 54F0        96            anl a, #0xf0 ; Clear the bits for timer 0
00F5 4401        97            orl a, #0x01 ; Configure timer 0 as 16-timer
00F7 F589        98            mov TMOD, a
00F9 758CA9      99            mov TH0, #high(TIMER0_RELOAD)
00FC 758AD6     100            mov TL0, #low(TIMER0_RELOAD)
00FF            101            ; Enable the timer and interrupts
00FF D2A9       102       setb ET0  ; Enable timer 0 interrupt
0101 D28C       103       setb TR0  ; Start timer 0
0103 22         104            ret
0104            105   
0104            106   ;---------------------------------;
0104            107   ; ISR for timer 0.                ;
0104            108   ;---------------------------------;
0104            109   Timer0_ISR:
0104            110            ;clr TF0  ; According to the data sheet this is done for us already.
0104            111            ; Timer 0 can not autoreload so we need to reload it in the ISR:
0104 C28C       112            clr TR0
0106 758CA9     113            mov TH0, #high(TIMER0_RELOAD)
0109 758AD6     114            mov TL0, #low(TIMER0_RELOAD)
010C D28C       115            setb TR0
010E B2A1       116            cpl SOUND_OUT ; Toggle the pin connected to the speaker
0110 32         117            reti
0111            118   
0111            119   ;---------------------------------;
0111            120   ; Routine to initialize timer 2   ;
0111            121   ;---------------------------------;
0111            122   Timer2_Init:
0111 438E10     123            orl CKCON0, #0b00010000 ; Timer 2 uses the system clock
0114 75C800     124            mov TMR2CN0, #0 ; Stop timer/counter.  Autoreload mode.
0117 75CFA2     125            mov TMR2H, #high(TIMER2_RELOAD)
011A 75CE40     126            mov TMR2L, #low(TIMER2_RELOAD)
011D            127            ; Set the reload value
011D 75CBA2     128            mov TMR2RLH, #high(TIMER2_RELOAD)
0120 75CA40     129            mov TMR2RLL, #low(TIMER2_RELOAD)
0123            130            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0123 E4         131            clr a
0124 F530       132            mov Count1ms+0, a
0126 F531       133            mov Count1ms+1, a
0128            134            ; Enable the timer and interrupts
0128 D2AD       135       setb ET2  ; Enable timer 2 interrupt
012A D2CA       136       setb TR2  ; Enable timer 2
012C 22         137            ret
012D            138   
012D            139   ;---------------------------------;
012D            140   ; ISR for timer 2                 ;
012D            141   ;---------------------------------;
012D            142   Timer2_ISR:
012D C2CF       143            clr TF2H  ; Timer 2 doesn't clear TF2H automatically. Do it in ISR
012F            144            
012F            145            ; The two registers used in the ISR must be saved in the stack
012F C0E0       146            push acc
0131 C0D0       147            push psw
0133            148            
0133            149            ; Increment the 16-bit one mili second counter
0133 0530       150            inc Count1ms+0    ; Increment the low 8-bits first
0135 E530       151            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0137 7002       152            jnz Inc_Done
0139 0531       153            inc Count1ms+1
013B            154   
013B            155   Inc_Done:
013B            156            ; Check if half second has passed
013B E530       157            mov a, Count1ms+0
013D B4F419     158            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0140 E531       159            mov a, Count1ms+1
0142 B40114     160            cjne a, #high(500), Timer2_ISR_done
0145            161            
0145            162            ; 500 milliseconds have passed.  Set a flag so the main program knows
0145 D200       163            setb half_seconds_flag ; Let the main program know half second had passed
0147 B28C       164            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0149 D2A1       165            setb SOUND_OUT
014B            166            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
014B E4         167            clr a
014C F530       168            mov Count1ms+0, a
014E F531       169            mov Count1ms+1, a
0150            170            ; Increment the BCD counter
0150 E536       171            mov a, CurrentSecond
0152            172            ;jnb UPDOWN, Timer2_ISR_decrement
0152 2401       173            add a, #0x01
0154 8000       174            sjmp Timer2_ISR_da
0156            175   ;Timer2_ISR_decrement:
0156            176            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0156            177   Timer2_ISR_da:
0156 D4         178            da a ; Decimal adjust instruction.  Check datasheet for more details!
0157 F536       179            mov CurrentSecond, a
0159            180            
0159            181   Timer2_ISR_done:
0159 D0D0       182            pop psw
015B D0E0       183            pop acc
015D 32         184            reti
015E            185   
015E            186   
015E            187   ;---------------------------------;
015E            188   ; Hardware initialization         ;
015E            189   ;---------------------------------;
015E            190   Initialize_All:
015E            191       ; DISABLE WDT: provide Watchdog disable keys
015E 7597DE     192            mov     WDTCN,#0xDE ; First key
0161 7597AD     193            mov     WDTCN,#0xAD ; Second key
0164            194   
0164            195            ; Setup the stack start to the begining of memory only accesible with pointers
0164 75817F     196       mov SP, #7FH
0167            197       
0167            198       ; Enable crossbar and weak pull-ups
0167 75E100     199            mov     XBR0,#0x00
016A 75E200     200            mov     XBR1,#0x00
016D 75E340     201            mov     XBR2,#0x40
0170            202   
0170 75A602     203            mov     P2MDOUT,#0x02 ; make sound output pin (P2.1) push-pull
0173            204            
0173            205            ; Switch clock to 24 MHz
0173 75A900     206            mov     CLKSEL, #0x00 ; 
0176 75A900     207            mov     CLKSEL, #0x00 ; Second write to CLKSEL is required according to the user manual (page 77)
0179            208            
0179            209            ; Wait for 24 MHz clock to stabilze by checking bit DIVRDY in CLKSEL
0179            210   waitclockstable:
0179 E5A9       211            mov a, CLKSEL
017B 30E7FB     212            jnb acc.7, waitclockstable 
017E            213   
017E            214            ; Initialize the two timers used in this program
017E 1200EE     215       lcall Timer0_Init
0181 120111     216       lcall Timer2_Init
0184            217   
0184 12008E     218       lcall LCD_4BIT ; Initialize LCD
0187            219       
0187 D2AF       220       setb EA   ; Enable Global interrupts
0189            221   
0189 22         222            ret
018A            223   
018A            224   MinuteIncrement:
018A E4         225            clr a 
018B E534       226            mov a, CurrentMinute
018D            227            ;jnb UPDOWN, Timer2_ISR_decrement
018D 2401       228            add a, #0x01
018F 8000       229            sjmp Timer2_ISR_da_minute
0191            230   ;Timer2_ISR_decrement:
0191            231            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0191            232   Timer2_ISR_da_minute:
0191 D4         233            da a ; Decimal adjust instruction.  Check datasheet for more details!
0192 F534       234            mov CurrentMinute, a
0194 22         235            ret
0195            236   
0195            237   HourIncrement:
0195 E4         238            clr a 
0196 E532       239            mov a, CurrentHour
0198            240            ;jnb UPDOWN, Timer2_ISR_decrement
0198 2401       241            add a, #0x01
019A 8000       242            sjmp Timer2_ISR_da_hour
019C            243   ;Timer2_ISR_decrement:
019C            244            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
019C            245   Timer2_ISR_da_hour:
019C D4         246            da a ; Decimal adjust instruction.  Check datasheet for more details!
019D F532       247            mov CurrentHour, a
019F 22         248            ret
01A0            249   ;---------------------------------;
01A0            250   ; Main program.                   ;
01A0            251   ;---------------------------------;
01A0            252   main:
01A0 12015E     253            lcall Initialize_All
01A3            254            
01A3            255       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
01A3 C0E0       256            push acc
01A5 7401       256            mov a, #1
01A7 14         256            dec a
01A8 1200C7     256            lcall ?Set_Cursor_1 ; Select column and row
01AB D0E0       256            pop acc
01AD C083       257            push dph
01AF C082       257            push dpl
01B1 C0E0       257            push acc
01B3 9000E2     257            mov dptr, #Initial_Message
01B6 1200BA     257            lcall ?Send_Constant_String
01B9 D0E0       257            pop acc
01BB D082       257            pop dpl
01BD D083       257            pop dph
01BF C0E0       258            push acc
01C1 740A       258            mov a, #10
01C3 14         258            dec a
01C4 1200C7     258            lcall ?Set_Cursor_1 ; Select column and row
01C7 D0E0       258            pop acc
01C9            259   
01C9 D200       260       setb half_seconds_flag
01CB 753200     261            mov CurrentHour, #0x00
01CE 753400     262       mov CurrentMinute, #0x00
01D1 753600     263       mov CurrentSecond, #0x00
01D4            264       ; TODO don't know if AM/PM should be here yet
01D4            265   
01D4 C0E0       266            push acc
01D6 740A       266            mov a, #10
01D8 14         266            dec a
01D9 1200C7     266            lcall ?Set_Cursor_1 ; Select column and row
01DC D0E0       266            pop acc
01DE C083       267            push dph
01E0 C082       267            push dpl
01E2 C0E0       267            push acc
01E4 90002E     267            mov dptr, #AM
01E7 1200BA     267            lcall ?Send_Constant_String
01EA D0E0       267            pop acc
01EC D082       267            pop dpl
01EE D083       267            pop dph ; intialise with AM
01F0 754001     268            mov is_AM, #1
01F3            269   
01F3            270   
01F3            271            ; After initialization the program stays in this 'forever' loop
01F3            272   loop:
01F3 20B71C     273            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
01F6 C002       274            push AR2
01F8 7A32       274            mov R2, #50
01FA 12003F     274            lcall ?Wait_Milli_Seconds
01FD D002       274            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01FF 20B710     275            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
0202 30B7FD     276            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
0205            277            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
0205            278            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
0205 C2CA       279            clr TR2                 ; Stop timer 2
0207 E4         280            clr a
0208 F530       281            mov Count1ms+0, a
020A F531       282            mov Count1ms+1, a
020C            283            ; Now clear the BCD counter
020C            284            ;mov CurrentHour, a
020C            285       ;mov CurrentMinute, a
020C F536       286       mov CurrentSecond, a
020E D2CA       287            setb TR2                ; Start timer 2
0210 8003       288            sjmp AMPM            ; Display the new value
0212            289   loop_a:
0212 3000DE     290            jnb half_seconds_flag, loop
0215            291   
0215            292   AMPM:
0215 20804A     293            jb AMPM_SET, loop_b
0218            294       ;Wait_Milli_Seconds(#50) ; not really necessary here
0218            295       ;jb AMPM_SET, loop_b
0218 308000     296            jnb AMPM_SET, AMPM_Display ; otherwise, continue
021B            297   
021B            298   AMPM_Display:
021B E540       299            mov a, is_AM
021D B40021     300            cjne a, #0, Display_PM ; if button is pressed and the flag is currently AM, set to PM
0220 C0E0       301            push acc
0222 740A       301            mov a, #10
0224 14         301            dec a
0225 1200C7     301            lcall ?Set_Cursor_1 ; Select column and row
0228 D0E0       301            pop acc
022A            301   
022A C083       302            push dph
022C C082       302            push dpl
022E C0E0       302            push acc
0230 90002E     302            mov dptr, #AM
0233 1200BA     302            lcall ?Send_Constant_String
0236 D0E0       302            pop acc
0238 D082       302            pop dpl
023A D083       302            pop dph
023C            303            ;cpl AMPM_SET
023C 754001     304            mov is_AM, #1
023F            305            ;clr a
023F 8021       306            sjmp loop_b
0241            307            
0241            308   
0241            309   Display_PM:
0241 C0E0       310            push acc
0243 740A       310            mov a, #10
0245 14         310            dec a
0246 1200C7     310            lcall ?Set_Cursor_1 ; Select column and row
0249 D0E0       310            pop acc
024B            310   
024B C083       311            push dph
024D C082       311            push dpl
024F C0E0       311            push acc
0251 900031     311            mov dptr, #PM
0254 1200BA     311            lcall ?Send_Constant_String
0257 D0E0       311            pop acc
0259 D082       311            pop dpl
025B D083       311            pop dph
025D            312            ;cpl AMPM_SET   
025D 754000     313            mov is_AM, #0
0260            314            ;clr a
0260 8000       315            sjmp loop_b
0262            316   
0262            317   
0262            318   loop_b:
0262            319            ;displaying block
0262 C200       320       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0264            321            ;Set_Cursor(1, 10)
0264            322            ;Display_BCD(AM)
0264 C0E0       323            push acc
0266 7407       323            mov a, #7
0268 14         323            dec a
0269 1200C7     323            lcall ?Set_Cursor_1 ; Select column and row
026C D0E0       323            pop acc
026E C000       324            push ar0
0270 A836       324            mov r0, CurrentSecond
0272 1200CC     324            lcall ?Display_BCD
0275 D000       324            pop ar0
0277 C0E0       325            push acc
0279 7404       325            mov a, #4
027B 14         325            dec a
027C 1200C7     325            lcall ?Set_Cursor_1 ; Select column and row
027F D0E0       325            pop acc
0281 C000       326            push ar0
0283 A834       326            mov r0, CurrentMinute
0285 1200CC     326            lcall ?Display_BCD
0288 D000       326            pop ar0
028A C0E0       327            push acc
028C 7401       327            mov a, #1
028E 14         327            dec a
028F 1200C7     327            lcall ?Set_Cursor_1 ; Select column and row
0292 D0E0       327            pop acc
0294 C000       328            push ar0
0296 A832       328            mov r0, CurrentHour
0298 1200CC     328            lcall ?Display_BCD
029B D000       328            pop ar0
029D E536       329            mov a, CurrentSecond
029F B46048     330       cjne a, #60H, IntermediateLoop ; keep going if you haven't reached 60 yet, otherwise change minute place
02A2 E4         331            clr a
02A3 F536       332            mov CurrentSecond, a
02A5 C0E0       333            push acc
02A7 7407       333            mov a, #7
02A9 14         333            dec a
02AA 1200C7     333            lcall ?Set_Cursor_1 ; Select column and row
02AD D0E0       333            pop acc
02AF C000       334            push ar0
02B1 A836       334            mov r0, CurrentSecond
02B3 1200CC     334            lcall ?Display_BCD
02B6 D000       334            pop ar0
02B8 12018A     335            lcall MinuteIncrement
02BB            336            ;mov a, CurrentMinute
02BB            337            ;mov CurrentSecond, a
02BB C0E0       338            push acc
02BD 7404       338            mov a, #4
02BF 14         338            dec a
02C0 1200C7     338            lcall ?Set_Cursor_1 ; Select column and row
02C3 D0E0       338            pop acc     ; minutes place
02C5 C000       339            push ar0
02C7 A834       339            mov r0, CurrentMinute
02C9 1200CC     339            lcall ?Display_BCD
02CC D000       339            pop ar0
02CE E4         340            clr a
02CF E534       341            mov a, CurrentMinute
02D1 B46016     342            cjne a, #60H, IntermediateLoop ; send to Hour Increment
02D4 120195     343            lcall HourIncrement 
02D7 C0E0       344            push acc
02D9 7401       344            mov a, #1
02DB 14         344            dec a
02DC 1200C7     344            lcall ?Set_Cursor_1 ; Select column and row
02DF D0E0       344            pop acc     ; the place in the LCD where we want the BCD counter value
02E1 C000       345            push ar0
02E3 A832       345            mov r0, CurrentHour
02E5 1200CC     345            lcall ?Display_BCD
02E8 D000       345            pop ar0 ; This macro is also in 'LCD_4bit.inc'
02EA            346   
02EA            347   
02EA            348   
02EA            349   IntermediateLoop:
02EA 0201F3     350            ljmp loop
02ED            351   
02ED            352   END
