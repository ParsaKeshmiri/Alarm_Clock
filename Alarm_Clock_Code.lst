0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 440 Hz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P3.7 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 24000000 ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 544*2    ; Tone changed to C#
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/(TIMER0_RATE))))
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/(TIMER2_RATE))))
0000             15   
0000             16   BOOT_BUTTON   equ P3.7
0000             17   SOUND_OUT     equ P2.1
0000             18   UPDOWN        equ P0.0
0000             19   
0000             20   ; Reset vector
0000             21   org 0x0000
0000 0201A7      22       ljmp main
0003             23   
0003             24   ; External interrupt 0 vector (not used in this code)
0003             25   org 0x0003
0003 32          26            reti
0004             27   
0004             28   ; Timer/Counter 0 overflow interrupt vector
000B             29   org 0x000B
000B 0200FE      30            ljmp Timer0_ISR
000E             31   
000E             32   ; External interrupt 1 vector (not used in this code)
0013             33   org 0x0013
0013 32          34            reti
0014             35   
0014             36   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             37   org 0x001B
001B 32          38            reti
001C             39   
001C             40   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             41   org 0x0023 
0023 32          42            reti
0024             43            
0024             44   ; Timer/Counter 2 overflow interrupt vector
002B             45   org 0x002B
002B 020127      46            ljmp Timer2_ISR
002E             47   
002E             48   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             49   dseg at 0x30
0030             50   Count1ms:      ds 2 ; Used to determine when half second has passed
0032             51   CurrentHour:   ds 2  
0034             52   CurrentMinute: ds 2
0036             53   CurrentSecond: ds 2
0038             54   CurrentAMPM:    ds 1
0039             55   AlarmHour:     ds 2
003B             56   AlarmMinute:   ds 2
003D             57   AlarmSecond:   ds 2
003F             58   AlarmAMPM:      ds 1
0040             59   
0040             60   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0040             61   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             62   bseg
0000             63   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             64   
002E             65   cseg
002E             66   ; These 'equ' must match the wiring between the microcontroller and the LCD!
002E             67   LCD_RS equ P2.0
002E             68   LCD_RW equ P1.7
002E             69   LCD_E  equ P1.6
002E             70   LCD_D4 equ P1.1
002E             71   LCD_D5 equ P1.0
002E             72   LCD_D6 equ P0.7
002E             73   LCD_D7 equ P0.6
                 75   	$LIST
00DC             77   
00DC             78   ;                     1234567890123456    <- This helps determine the location of the counter
00DC 78783A78    79   Initial_Message:  db 'xx:xx:xx xx', 0 ; hour:minute:second am/pm
     783A7878
     20787800
00E8             80   
00E8             81   ;-----------------------------------;
00E8             82   ; Routine to initialize the timer 0 ;
00E8             83   ;-----------------------------------;
00E8             84   Timer0_Init:
00E8 438E04      85            orl CKCON0, #00000100B ; Timer 0 uses the system clock
00EB E589        86            mov a, TMOD
00ED 54F0        87            anl a, #0xf0 ; Clear the bits for timer 0
00EF 4401        88            orl a, #0x01 ; Configure timer 0 as 16-timer
00F1 F589        89            mov TMOD, a
00F3 758CA9      90            mov TH0, #high(TIMER0_RELOAD)
00F6 758AD6      91            mov TL0, #low(TIMER0_RELOAD)
00F9             92            ; Enable the timer and interrupts
00F9 D2A9        93       setb ET0  ; Enable timer 0 interrupt
00FB D28C        94       setb TR0  ; Start timer 0
00FD 22          95            ret
00FE             96   
00FE             97   ;---------------------------------;
00FE             98   ; ISR for timer 0.                ;
00FE             99   ;---------------------------------;
00FE            100   Timer0_ISR:
00FE            101            ;clr TF0  ; According to the data sheet this is done for us already.
00FE            102            ; Timer 0 can not autoreload so we need to reload it in the ISR:
00FE C28C       103            clr TR0
0100 758CA9     104            mov TH0, #high(TIMER0_RELOAD)
0103 758AD6     105            mov TL0, #low(TIMER0_RELOAD)
0106 D28C       106            setb TR0
0108 B2A1       107            cpl SOUND_OUT ; Toggle the pin connected to the speaker
010A 32         108            reti
010B            109   
010B            110   ;---------------------------------;
010B            111   ; Routine to initialize timer 2   ;
010B            112   ;---------------------------------;
010B            113   Timer2_Init:
010B 438E10     114            orl CKCON0, #0b00010000 ; Timer 2 uses the system clock
010E 75C800     115            mov TMR2CN0, #0 ; Stop timer/counter.  Autoreload mode.
0111 75CFA2     116            mov TMR2H, #high(TIMER2_RELOAD)
0114 75CE40     117            mov TMR2L, #low(TIMER2_RELOAD)
0117            118            ; Set the reload value
0117 75CBA2     119            mov TMR2RLH, #high(TIMER2_RELOAD)
011A 75CA40     120            mov TMR2RLL, #low(TIMER2_RELOAD)
011D            121            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
011D E4         122            clr a
011E F530       123            mov Count1ms+0, a
0120 F531       124            mov Count1ms+1, a
0122            125            ; Enable the timer and interrupts
0122 D2AD       126       setb ET2  ; Enable timer 2 interrupt
0124 D2CA       127       setb TR2  ; Enable timer 2
0126 22         128            ret
0127            129   
0127            130   ;---------------------------------;
0127            131   ; ISR for timer 2                 ;
0127            132   ;---------------------------------;
0127            133   Timer2_ISR:
0127 C2CF       134            clr TF2H  ; Timer 2 doesn't clear TF2H automatically. Do it in ISR
0129            135            
0129            136            ; The two registers used in the ISR must be saved in the stack
0129 C0E0       137            push acc
012B C0D0       138            push psw
012D            139            
012D            140            ; Increment the 16-bit one mili second counter
012D 0530       141            inc Count1ms+0    ; Increment the low 8-bits first
012F E530       142            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0131 7002       143            jnz Inc_Done
0133 0531       144            inc Count1ms+1
0135            145   
0135            146   Inc_Done:
0135            147            ; Check if half second has passed
0135 E530       148            mov a, Count1ms+0
0137 B4F419     149            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
013A E531       150            mov a, Count1ms+1
013C B40114     151            cjne a, #high(500), Timer2_ISR_done
013F            152            
013F            153            ; 500 milliseconds have passed.  Set a flag so the main program knows
013F D200       154            setb half_seconds_flag ; Let the main program know half second had passed
0141 B28C       155            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0143 D2A1       156            setb SOUND_OUT
0145            157            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0145 E4         158            clr a
0146 F530       159            mov Count1ms+0, a
0148 F531       160            mov Count1ms+1, a
014A            161            ; Increment the BCD counter
014A E536       162            mov a, CurrentSecond
014C            163            ;jnb UPDOWN, Timer2_ISR_decrement
014C 2401       164            add a, #0x01
014E 8000       165            sjmp Timer2_ISR_da
0150            166   ;Timer2_ISR_decrement:
0150            167            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0150            168   Timer2_ISR_da:
0150 D4         169            da a ; Decimal adjust instruction.  Check datasheet for more details!
0151 F536       170            mov CurrentSecond, a
0153            171            
0153            172   Timer2_ISR_done:
0153 D0D0       173            pop psw
0155 D0E0       174            pop acc
0157 32         175            reti
0158            176   
0158            177   MinuteIncrement:
0158            178            ; Check if half second has passed
0158 E530       179            mov a, Count1ms+0
015A B4F419     180            cjne a, #low(500), Timer2_ISR_done_minute ; Warning: this instruction changes the carry flag!
015D E531       181            mov a, Count1ms+1
015F B40114     182            cjne a, #high(500), Timer2_ISR_done_minute
0162            183            
0162            184            ; 500 milliseconds have passed.  Set a flag so the main program knows
0162 D200       185            setb half_seconds_flag ; Let the main program know half second had passed
0164 B28C       186            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0166 D2A1       187            setb SOUND_OUT
0168            188            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0168 E4         189            clr a
0169 F530       190            mov Count1ms+0, a
016B F531       191            mov Count1ms+1, a
016D            192            ; Increment the BCD counter
016D E534       193            mov a, CurrentMinute
016F            194            ;jnb UPDOWN, Timer2_ISR_decrement
016F 2401       195            add a, #0x01
0171 8000       196            sjmp Timer2_ISR_da_minutes
0173            197   ;Timer2_ISR_decrement:
0173            198            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0173            199   Timer2_ISR_da_minutes:
0173 D4         200            da a ; Decimal adjust instruction.  Check datasheet for more details!
0174 F534       201            mov CurrentMinute, a
0176            202            
0176            203   Timer2_ISR_done_minute:
0176 D0D0       204            pop psw
0178 D0E0       205            pop acc
017A 32         206            reti
017B            207   
017B            208   
017B            209   HourIncrement:
017B            210   
017B            211   ;---------------------------------;
017B            212   ; Hardware initialization         ;
017B            213   ;---------------------------------;
017B            214   Initialize_All:
017B            215       ; DISABLE WDT: provide Watchdog disable keys
017B 7597DE     216            mov     WDTCN,#0xDE ; First key
017E 7597AD     217            mov     WDTCN,#0xAD ; Second key
0181            218   
0181            219            ; Setup the stack start to the begining of memory only accesible with pointers
0181 75817F     220       mov SP, #7FH
0184            221       
0184            222       ; Enable crossbar and weak pull-ups
0184 75E100     223            mov     XBR0,#0x00
0187 75E200     224            mov     XBR1,#0x00
018A 75E340     225            mov     XBR2,#0x40
018D            226   
018D 75A602     227            mov     P2MDOUT,#0x02 ; make sound output pin (P2.1) push-pull
0190            228            
0190            229            ; Switch clock to 24 MHz
0190 75A900     230            mov     CLKSEL, #0x00 ; 
0193 75A900     231            mov     CLKSEL, #0x00 ; Second write to CLKSEL is required according to the user manual (page 77)
0196            232            
0196            233            ; Wait for 24 MHz clock to stabilze by checking bit DIVRDY in CLKSEL
0196            234   waitclockstable:
0196 E5A9       235            mov a, CLKSEL
0198 30E7FB     236            jnb acc.7, waitclockstable 
019B            237   
019B            238            ; Initialize the two timers used in this program
019B 1200E8     239       lcall Timer0_Init
019E 12010B     240       lcall Timer2_Init
01A1            241   
01A1 120088     242       lcall LCD_4BIT ; Initialize LCD
01A4            243       
01A4 D2AF       244       setb EA   ; Enable Global interrupts
01A6            245   
01A6 22         246            ret
01A7            247   
01A7            248   ;---------------------------------;
01A7            249   ; Main program.                   ;
01A7            250   ;---------------------------------;
01A7            251   main:
01A7 12017B     252            lcall Initialize_All
01AA            253            
01AA            254       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
01AA C0E0       255            push acc
01AC 7401       255            mov a, #1
01AE 14         255            dec a
01AF 1200C1     255            lcall ?Set_Cursor_1 ; Select column and row
01B2 D0E0       255            pop acc
01B4 C083       256            push dph
01B6 C082       256            push dpl
01B8 C0E0       256            push acc
01BA 9000DC     256            mov dptr, #Initial_Message
01BD 1200B4     256            lcall ?Send_Constant_String
01C0 D0E0       256            pop acc
01C2 D082       256            pop dpl
01C4 D083       256            pop dph
01C6 D200       257       setb half_seconds_flag
01C8 753200     258            mov CurrentHour, #0x00
01CB 753400     259       mov CurrentMinute, #0x00
01CE 753600     260       mov CurrentSecond, #0x00
01D1            261       ; TODO don't know if AM/PM should be here yet
01D1            262            
01D1            263            ; After initialization the program stays in this 'forever' loop
01D1            264   loop:
01D1 20B720     265            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
01D4 C002       266            push AR2
01D6 7A32       266            mov R2, #50
01D8 120039     266            lcall ?Wait_Milli_Seconds
01DB D002       266            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01DD 20B714     267            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
01E0 30B7FD     268            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
01E3            269            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
01E3            270            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
01E3 C2CA       271            clr TR2                 ; Stop timer 2
01E5 E4         272            clr a
01E6 F530       273            mov Count1ms+0, a
01E8 F531       274            mov Count1ms+1, a
01EA            275            ; Now clear the BCD counter
01EA F532       276            mov CurrentHour, a
01EC F534       277       mov CurrentMinute, a
01EE F536       278       mov CurrentSecond, a
01F0 D2CA       279            setb TR2                ; Start timer 2
01F2 8003       280            sjmp loop_b             ; Display the new value
01F4            281   loop_a:
01F4 3000DA     282            jnb half_seconds_flag, loop
01F7            283   loop_b:
01F7 C200       284       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
01F9 C0E0       285            push acc
01FB 7401       285            mov a, #1
01FD 14         285            dec a
01FE 1200C1     285            lcall ?Set_Cursor_1 ; Select column and row
0201 D0E0       285            pop acc     ; the place in the LCD where we want the BCD counter value
0203 C000       286            push ar0
0205 A832       286            mov r0, CurrentHour
0207 1200C6     286            lcall ?Display_BCD
020A D000       286            pop ar0 ; This macro is also in 'LCD_4bit.inc'
020C C0E0       287            push acc
020E 7404       287            mov a, #4
0210 14         287            dec a
0211 1200C1     287            lcall ?Set_Cursor_1 ; Select column and row
0214 D0E0       287            pop acc     ; minutes place
0216 C000       288            push ar0
0218 A834       288            mov r0, CurrentMinute
021A 1200C6     288            lcall ?Display_BCD
021D D000       288            pop ar0
021F C0E0       289            push acc
0221 7407       289            mov a, #7
0223 14         289            dec a
0224 1200C1     289            lcall ?Set_Cursor_1 ; Select column and row
0227 D0E0       289            pop acc
0229 C000       290            push ar0
022B A836       290            mov r0, CurrentSecond
022D 1200C6     290            lcall ?Display_BCD
0230 D000       290            pop ar0
0232            291   
0232            292       ;mov a, CurrentSecond
0232            293       ;cjne a, #0xC2, loop ; keep going if you haven't reached 60 yet, otherwise change minute place
0232            294       ;clr a
0232 E534       295       mov a, CurrentMinute
0234            296       ;cjne a, #0xC2, MinuteIncrement ; if minutes isn't 59 currently, then incrememnt minutes
0234 02017B     297       ljmp HourIncrement
0237            298   END
