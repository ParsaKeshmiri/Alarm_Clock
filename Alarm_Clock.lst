0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 440 Hz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P3.7 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 24000000 ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 544*2    ; Tone changed to C#
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/(TIMER0_RATE))))
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/(TIMER2_RATE))))
0000             15   
0000             16   ;TODO if time: Add power button
0000             17   AMPM_SET           equ P0.0 ; switch between AM and PM
0000             18   CA_SWITCH     equ P0.1 ; switches buttons between controlling clock and alarm
0000             19   ALARM_OFF     equ P0.3 ; turns off alarm sound
0000             20   SOUND_OUT     equ P2.1
0000             21   SECONDS       equ P2.3 ; adjust seconds
0000             22   MINUTES            equ P2.6 ; adjust minutes
0000             23   HOURS              equ P3.2 ; adjust hours
0000             24   BOOT_BUTTON   equ P3.7
0000             25   
0000             26   ; Reset vector
0000             27   org 0x0000
0000 0201E8      28       ljmp main
0003             29   
0003             30   ; External interrupt 0 vector (not used in this code)
0003             31   org 0x0003
0003 32          32            reti
0004             33   
0004             34   ; Timer/Counter 0 overflow interrupt vector
000B             35   org 0x000B
000B 02010A      36            ljmp Timer0_ISR
000E             37   
000E             38   ; External interrupt 1 vector (not used in this code)
0013             39   org 0x0013
0013 32          40            reti
0014             41   
0014             42   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             43   org 0x001B
001B 32          44            reti
001C             45   
001C             46   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             47   org 0x0023 
0023 32          48            reti
0024             49            
0024             50   ; Timer/Counter 2 overflow interrupt vector
002B             51   org 0x002B
002B 020133      52            ljmp Timer2_ISR
002E             53   
002E             54   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             55   dseg at 0x30
0030             56   Count1ms:        ds 2 ; Used to determine when half second has passed
0032             57   CurrentHour:     ds 2  
0034             58   CurrentMinute:   ds 2
0036             59   CurrentSecond:   ds 2
0038             60   CurrentAMPM:     ds 1
0039             61   AlarmHour:       ds 2
003B             62   AlarmMinute:     ds 2
003D             63   AlarmSecond:     ds 2
003F             64   AlarmAMPM:       ds 1
0040             65   is_AM:           ds 1
0041             66   is_Clock:        ds 1
002E 414D00      67   AM: db 'AM', 0 
0031 504D00      68   PM: db 'PM', 0
0034             69   
0034             70   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0034             71   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             72   bseg
0000             73   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             74   
0034             75   cseg
0034             76   ; These 'equ' must match the wiring between the microcontroller and the LCD!
0034             77   LCD_RS equ P2.0
0034             78   LCD_RW equ P1.7
0034             79   LCD_E  equ P1.6
0034             80   LCD_D4 equ P1.1
0034             81   LCD_D5 equ P1.0
0034             82   LCD_D6 equ P0.7
0034             83   LCD_D7 equ P0.6
                 85   	$LIST
00E2             87   
00E2             88   ;                           1234567890123456    <- This helps determine the location of the counter
00E2 3C2D00      89   Point:                  db '<-', 0 ; hour:minute:second am/pm
00E5 78783A78    90   Initial_Message:        db 'xx:xx:xx xx', 0
     783A7878
     20787800
00F1 202000      91   Clear:                  db '  ', 0
00F4             92   
00F4             93   ;-----------------------------------;
00F4             94   ; Routine to initialize the timer 0 ;
00F4             95   ;-----------------------------------;
00F4             96   Timer0_Init:
00F4 438E04      97            orl CKCON0, #00000100B ; Timer 0 uses the system clock
00F7 E589        98            mov a, TMOD
00F9 54F0        99            anl a, #0xf0 ; Clear the bits for timer 0
00FB 4401       100            orl a, #0x01 ; Configure timer 0 as 16-timer
00FD F589       101            mov TMOD, a
00FF 758CA9     102            mov TH0, #high(TIMER0_RELOAD)
0102 758AD6     103            mov TL0, #low(TIMER0_RELOAD)
0105            104            ; Enable the timer and interrupts
0105 D2A9       105       setb ET0  ; Enable timer 0 interrupt
0107 D28C       106       setb TR0  ; Start timer 0
0109 22         107            ret
010A            108   
010A            109   ;---------------------------------;
010A            110   ; ISR for timer 0.                ;
010A            111   ;---------------------------------;
010A            112   Timer0_ISR:
010A            113            ;clr TF0  ; According to the data sheet this is done for us already.
010A            114            ; Timer 0 can not autoreload so we need to reload it in the ISR:
010A C28C       115            clr TR0
010C 758CA9     116            mov TH0, #high(TIMER0_RELOAD)
010F 758AD6     117            mov TL0, #low(TIMER0_RELOAD)
0112 D28C       118            setb TR0
0114 B2A1       119            cpl SOUND_OUT ; Toggle the pin connected to the speaker
0116 32         120            reti
0117            121   
0117            122   ;---------------------------------;
0117            123   ; Routine to initialize timer 2   ;
0117            124   ;---------------------------------;
0117            125   Timer2_Init:
0117 438E10     126            orl CKCON0, #0b00010000 ; Timer 2 uses the system clock
011A 75C800     127            mov TMR2CN0, #0 ; Stop timer/counter.  Autoreload mode.
011D 75CFA2     128            mov TMR2H, #high(TIMER2_RELOAD)
0120 75CE40     129            mov TMR2L, #low(TIMER2_RELOAD)
0123            130            ; Set the reload value
0123 75CBA2     131            mov TMR2RLH, #high(TIMER2_RELOAD)
0126 75CA40     132            mov TMR2RLL, #low(TIMER2_RELOAD)
0129            133            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0129 E4         134            clr a
012A F530       135            mov Count1ms+0, a
012C F531       136            mov Count1ms+1, a
012E            137            ; Enable the timer and interrupts
012E D2AD       138       setb ET2  ; Enable timer 2 interrupt
0130 D2CA       139       setb TR2  ; Enable timer 2
0132 22         140            ret
0133            141   
0133            142   ;---------------------------------;
0133            143   ; ISR for timer 2                 ;
0133            144   ;---------------------------------;
0133            145   Timer2_ISR:
0133 C2CF       146            clr TF2H  ; Timer 2 doesn't clear TF2H automatically. Do it in ISR
0135            147            
0135            148            ; The two registers used in the ISR must be saved in the stack
0135 C0E0       149            push acc
0137 C0D0       150            push psw
0139            151            
0139            152            ; Increment the 16-bit one mili second counter
0139 0530       153            inc Count1ms+0    ; Increment the low 8-bits first
013B E530       154            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
013D 7002       155            jnz Inc_Done
013F 0531       156            inc Count1ms+1
0141            157   
0141            158   Inc_Done:
0141            159            ; Check if half second has passed
0141 E530       160            mov a, Count1ms+0
0143 B4F419     161            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0146 E531       162            mov a, Count1ms+1
0148 B40114     163            cjne a, #high(500), Timer2_ISR_done
014B            164            
014B            165            ; 500 milliseconds have passed.  Set a flag so the main program knows
014B D200       166            setb half_seconds_flag ; Let the main program know half second had passed
014D B28C       167            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
014F D2A1       168            setb SOUND_OUT
0151            169            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0151 E4         170            clr a
0152 F530       171            mov Count1ms+0, a
0154 F531       172            mov Count1ms+1, a
0156            173            ; Increment the BCD counter
0156 E536       174            mov a, CurrentSecond
0158            175            ;jnb UPDOWN, Timer2_ISR_decrement
0158 2401       176            add a, #0x01
015A 8000       177            sjmp Timer2_ISR_da
015C            178   ;Timer2_ISR_decrement:
015C            179            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
015C            180   Timer2_ISR_da:
015C D4         181            da a ; Decimal adjust instruction.  Check datasheet for more details!
015D F536       182            mov CurrentSecond, a
015F            183            
015F            184   Timer2_ISR_done:
015F D0D0       185            pop psw
0161 D0E0       186            pop acc
0163 32         187            reti
0164            188   
0164            189   
0164            190   ;---------------------------------;
0164            191   ; Hardware initialization         ;
0164            192   ;---------------------------------;
0164            193   Initialize_All:
0164            194       ; DISABLE WDT: provide Watchdog disable keys
0164 7597DE     195            mov     WDTCN,#0xDE ; First key
0167 7597AD     196            mov     WDTCN,#0xAD ; Second key
016A            197   
016A            198            ; Setup the stack start to the begining of memory only accesible with pointers
016A 75817F     199       mov SP, #7FH
016D            200       
016D            201       ; Enable crossbar and weak pull-ups
016D 75E100     202            mov     XBR0,#0x00
0170 75E200     203            mov     XBR1,#0x00
0173 75E340     204            mov     XBR2,#0x40
0176            205   
0176 75A602     206            mov     P2MDOUT,#0x02 ; make sound output pin (P2.1) push-pull
0179            207            
0179            208            ; Switch clock to 24 MHz
0179 75A900     209            mov     CLKSEL, #0x00 ; 
017C 75A900     210            mov     CLKSEL, #0x00 ; Second write to CLKSEL is required according to the user manual (page 77)
017F            211            
017F            212            ; Wait for 24 MHz clock to stabilze by checking bit DIVRDY in CLKSEL
017F            213   waitclockstable:
017F E5A9       214            mov a, CLKSEL
0181 30E7FB     215            jnb acc.7, waitclockstable 
0184            216   
0184            217            ; Initialize the two timers used in this program
0184 1200F4     218       lcall Timer0_Init
0187 120117     219       lcall Timer2_Init
018A            220   
018A 12008E     221       lcall LCD_4BIT ; Initialize LCD
018D            222       
018D D2AF       223       setb EA   ; Enable Global interrupts
018F            224   
018F 22         225            ret
0190            226   
0190            227   MinuteIncrement:
0190 E541       228       mov a, is_Clock
0192 B4010B     229       cjne a, #1, Alarm_MinuteIncrement ; change Alarm variable instead 
0195 E4         230            clr a 
0196 E534       231            mov a, CurrentMinute
0198            232            ;jnb UPDOWN, Timer2_ISR_decrement
0198 2401       233            add a, #0x01
019A 8000       234            sjmp Timer2_ISR_da_minute
019C            235   ;Timer2_ISR_decrement:
019C            236            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
019C            237   Timer2_ISR_da_minute:
019C D4         238            da a ; Decimal adjust instruction.  Check datasheet for more details!
019D F534       239            mov CurrentMinute, a
019F 22         240            ret
01A0            241   
01A0            242   Alarm_MinuteIncrement:
01A0 E4         243       clr a
01A1 E53B       244       mov a, AlarmMinute
01A3 2401       245       add a, #0x01
01A5 D4         246       da a
01A6 F53B       247       mov AlarmMinute, a
01A8 C0E0       248            push acc
01AA 7404       248            mov a, #4
01AC 14         248            dec a
01AD 1200C5     248            lcall ?Set_Cursor_2 ; Select column and row
01B0 D0E0       248            pop acc
01B2 C000       249            push ar0
01B4 A83B       249            mov r0, AlarmMinute
01B6 1200CC     249            lcall ?Display_BCD
01B9 D000       249            pop ar0
01BB 22         250       ret
01BC            251   
01BC            252   HourIncrement:
01BC E541       253       mov a, is_Clock
01BE B4010B     254       cjne a, #1, Alarm_HourIncrement 
01C1 E4         255            clr a 
01C2 E532       256            mov a, CurrentHour
01C4            257            ;jnb UPDOWN, Timer2_ISR_decrement
01C4 2401       258            add a, #0x01
01C6 8000       259            sjmp Timer2_ISR_da_hour
01C8            260   ;Timer2_ISR_decrement:
01C8            261            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
01C8            262   Timer2_ISR_da_hour:
01C8 D4         263            da a ; Decimal adjust instruction.  Check datasheet for more details!
01C9 F532       264            mov CurrentHour, a
01CB 22         265            ret
01CC            266   
01CC            267   Alarm_HourIncrement:
01CC E4         268       clr a
01CD E539       269       mov a, AlarmHour
01CF 2401       270       add a, #0x01
01D1 D4         271       da a
01D2 F539       272       mov AlarmHour, a
01D4 C0E0       273            push acc
01D6 7401       273            mov a, #1
01D8 14         273            dec a
01D9 1200C5     273            lcall ?Set_Cursor_2 ; Select column and row
01DC D0E0       273            pop acc
01DE C000       274            push ar0
01E0 A839       274            mov r0, AlarmHour
01E2 1200CC     274            lcall ?Display_BCD
01E5 D000       274            pop ar0
01E7 22         275       ret
01E8            276   ;---------------------------------;
01E8            277   ; Main program.                   ;
01E8            278   ;---------------------------------;
01E8            279   main:
01E8 120164     280            lcall Initialize_All
01EB            281            
01EB            282       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
01EB C0E0       283            push acc
01ED 7401       283            mov a, #1
01EF 14         283            dec a
01F0 1200C7     283            lcall ?Set_Cursor_1 ; Select column and row
01F3 D0E0       283            pop acc
01F5 C083       284            push dph
01F7 C082       284            push dpl
01F9 C0E0       284            push acc
01FB 9000E5     284            mov dptr, #Initial_Message
01FE 1200BA     284            lcall ?Send_Constant_String
0201 D0E0       284            pop acc
0203 D082       284            pop dpl
0205 D083       284            pop dph
0207 C0E0       285            push acc
0209 740F       285            mov a, #15
020B 14         285            dec a
020C 1200C7     285            lcall ?Set_Cursor_1 ; Select column and row
020F D0E0       285            pop acc
0211 C083       286            push dph
0213 C082       286            push dpl
0215 C0E0       286            push acc
0217 9000E2     286            mov dptr, #Point
021A 1200BA     286            lcall ?Send_Constant_String
021D D0E0       286            pop acc
021F D082       286            pop dpl
0221 D083       286            pop dph
0223 C0E0       287            push acc
0225 7401       287            mov a, #1
0227 14         287            dec a
0228 1200C5     287            lcall ?Set_Cursor_2 ; Select column and row
022B D0E0       287            pop acc
022D C083       288            push dph
022F C082       288            push dpl
0231 C0E0       288            push acc
0233 9000E5     288            mov dptr, #Initial_Message
0236 1200BA     288            lcall ?Send_Constant_String
0239 D0E0       288            pop acc
023B D082       288            pop dpl
023D D083       288            pop dph
023F C0E0       289            push acc
0241 740A       289            mov a, #10
0243 14         289            dec a
0244 1200C7     289            lcall ?Set_Cursor_1 ; Select column and row
0247 D0E0       289            pop acc
0249            290   
0249 D200       291       setb half_seconds_flag
024B 753200     292            mov CurrentHour, #0x00
024E 753400     293       mov CurrentMinute, #0x00
0251 753600     294       mov CurrentSecond, #0x00
0254 753900     295       mov AlarmHour, #0x00
0257 753B00     296       mov AlarmMinute, #0x00
025A 753D00     297       mov AlarmSecond, #0x00
025D            298       ; TODO don't know if AM/PM should be here yet
025D            299   
025D C0E0       300            push acc
025F 740A       300            mov a, #10
0261 14         300            dec a
0262 1200C7     300            lcall ?Set_Cursor_1 ; Select column and row
0265 D0E0       300            pop acc
0267 C083       301            push dph
0269 C082       301            push dpl
026B C0E0       301            push acc
026D 90002E     301            mov dptr, #AM
0270 1200BA     301            lcall ?Send_Constant_String
0273 D0E0       301            pop acc
0275 D082       301            pop dpl
0277 D083       301            pop dph ; intialise with AM
0279            302   
0279 C0E0       303            push acc
027B 740A       303            mov a, #10
027D 14         303            dec a
027E 1200C5     303            lcall ?Set_Cursor_2 ; Select column and row
0281 D0E0       303            pop acc
0283            303   
0283 C083       304            push dph
0285 C082       304            push dpl
0287 C0E0       304            push acc
0289 90002E     304            mov dptr, #AM
028C 1200BA     304            lcall ?Send_Constant_String
028F D0E0       304            pop acc
0291 D082       304            pop dpl
0293 D083       304            pop dph ; intialise with AM
0295 754001     305            mov is_AM, #1
0298 754101     306       mov is_Clock, #1 ; as opposed to Alarm mode
029B            307   
029B            308   
029B            309            ; After initialization the program stays in this 'forever' loop
029B            310   loop:
029B 20B728     311            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
029E C002       312            push AR2
02A0 7A32       312            mov R2, #50
02A2 12003F     312            lcall ?Wait_Milli_Seconds
02A5 D002       312            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
02A7 20B71C     313            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
02AA 30B7FD     314            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
02AD            315            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
02AD            316            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
02AD C2CA       317            clr TR2                 ; Stop timer 2
02AF E4         318            clr a
02B0 F530       319            mov Count1ms+0, a
02B2 F531       320            mov Count1ms+1, a
02B4            321            ; Now clear the BCD counter
02B4            322            ;mov CurrentHour, a
02B4            323       ;mov CurrentMinute, a
02B4 F536       324       mov CurrentSecond, a
02B6 D2CA       325            setb TR2                ; Start timer 2
02B8            326   
02B8 800F       327            sjmp Button_Interrupt            ; Display the new value
02BA            328   
02BA            329   Add_Hour:
02BA 1201BC     330       lcall HourIncrement
02BD 0203A9     331       ljmp loop_b
02C0            332   
02C0            333   Add_Minute:
02C0 120190     334       lcall MinuteIncrement
02C3 0203A9     335       ljmp loop_b
02C6            336   
02C6            337   loop_a:
02C6 3000D2     338            jnb half_seconds_flag, loop
02C9            339   
02C9            340   Button_Interrupt:
02C9 30B2EE     341       jnb HOURS, Add_Hour
02CC 30A6F1     342       jnb MINUTES, Add_Minute
02CF 30A3C9     343       jnb SECONDS, loop
02D2 308109     344       jnb CA_SWITCH, SWITCH
02D5 208003     345            jb AMPM_SET, Send_to_Loop_B
02D8            346       ;Wait_Milli_Seconds(#50) ; not really necessary here
02D8            347       ;jb AMPM_SET, loop_b
02D8 308046     348            jnb AMPM_SET, to_AMPM_display ; otherwise, continue
02DB            349   
02DB            350   Send_to_Loop_B:
02DB 0203A9     351       ljmp loop_b
02DE            352   
02DE            353   
02DE            354   
02DE            355   SWITCH:
02DE E541       356       mov a, is_Clock
02E0 B40041     357       cjne a, #0, Alarm_Mode
02E3 C0E0       358            push acc
02E5 740F       358            mov a, #15
02E7 14         358            dec a
02E8 1200C7     358            lcall ?Set_Cursor_1 ; Select column and row
02EB D0E0       358            pop acc
02ED            358   
02ED C083       359            push dph
02EF C082       359            push dpl
02F1 C0E0       359            push acc
02F3 9000E2     359            mov dptr, #Point
02F6 1200BA     359            lcall ?Send_Constant_String
02F9 D0E0       359            pop acc
02FB D082       359            pop dpl
02FD D083       359            pop dph
02FF C0E0       360            push acc
0301 740F       360            mov a, #15
0303 14         360            dec a
0304 1200C5     360            lcall ?Set_Cursor_2 ; Select column and row
0307 D0E0       360            pop acc
0309 C083       361            push dph
030B C082       361            push dpl
030D C0E0       361            push acc
030F 9000F1     361            mov dptr, #Clear
0312 1200BA     361            lcall ?Send_Constant_String
0315 D0E0       361            pop acc
0317 D082       361            pop dpl
0319 D083       361            pop dph
031B 754101     362       mov is_Clock, #1
031E 0203A9     363       ljmp loop_b
0321            364   
0321            365   to_AMPM_display:
0321 020362     366       ljmp AMPM_Display
0324            367   
0324            368   Alarm_Mode:
0324 C0E0       369            push acc
0326 740F       369            mov a, #15
0328 14         369            dec a
0329 1200C7     369            lcall ?Set_Cursor_1 ; Select column and row
032C D0E0       369            pop acc
032E C083       370            push dph
0330 C082       370            push dpl
0332 C0E0       370            push acc
0334 9000F1     370            mov dptr, #Clear
0337 1200BA     370            lcall ?Send_Constant_String
033A D0E0       370            pop acc
033C D082       370            pop dpl
033E D083       370            pop dph
0340 C0E0       371            push acc
0342 740F       371            mov a, #15
0344 14         371            dec a
0345 1200C5     371            lcall ?Set_Cursor_2 ; Select column and row
0348 D0E0       371            pop acc
034A C083       372            push dph
034C C082       372            push dpl
034E C0E0       372            push acc
0350 9000E2     372            mov dptr, #Point
0353 1200BA     372            lcall ?Send_Constant_String
0356 D0E0       372            pop acc
0358 D082       372            pop dpl
035A D083       372            pop dph
035C 754100     373       mov is_Clock, #0
035F 0203A9     374       ljmp loop_b
0362            375   
0362            376   AMPM_Display:
0362 E540       377            mov a, is_AM
0364 B40021     378            cjne a, #0, Display_PM ; if button is pressed and the flag is currently AM, set to PM
0367 C0E0       379            push acc
0369 740A       379            mov a, #10
036B 14         379            dec a
036C 1200C7     379            lcall ?Set_Cursor_1 ; Select column and row
036F D0E0       379            pop acc
0371 C083       380            push dph
0373 C082       380            push dpl
0375 C0E0       380            push acc
0377 90002E     380            mov dptr, #AM
037A 1200BA     380            lcall ?Send_Constant_String
037D D0E0       380            pop acc
037F D082       380            pop dpl
0381 D083       380            pop dph
0383            381            ;cpl AMPM_SET
0383 754001     382            mov is_AM, #1
0386            383            ;clr a
0386 8021       384            sjmp loop_b
0388            385            
0388            386   
0388            387   Display_PM:
0388 C0E0       388            push acc
038A 740A       388            mov a, #10
038C 14         388            dec a
038D 1200C7     388            lcall ?Set_Cursor_1 ; Select column and row
0390 D0E0       388            pop acc
0392            388   
0392 C083       389            push dph
0394 C082       389            push dpl
0396 C0E0       389            push acc
0398 900031     389            mov dptr, #PM
039B 1200BA     389            lcall ?Send_Constant_String
039E D0E0       389            pop acc
03A0 D082       389            pop dpl
03A2 D083       389            pop dph
03A4            390            ;cpl AMPM_SET   
03A4 754000     391            mov is_AM, #0
03A7            392            ;clr a
03A7 8000       393            sjmp loop_b
03A9            394   
03A9            395   
03A9            396   loop_b:
03A9            397            ;displaying block
03A9 C200       398       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
03AB            399            ;Set_Cursor(1, 10)
03AB            400            ;Display_BCD(AM)
03AB C0E0       401            push acc
03AD 7407       401            mov a, #7
03AF 14         401            dec a
03B0 1200C7     401            lcall ?Set_Cursor_1 ; Select column and row
03B3 D0E0       401            pop acc
03B5 C000       402            push ar0
03B7 A836       402            mov r0, CurrentSecond
03B9 1200CC     402            lcall ?Display_BCD
03BC D000       402            pop ar0
03BE C0E0       403            push acc
03C0 7404       403            mov a, #4
03C2 14         403            dec a
03C3 1200C7     403            lcall ?Set_Cursor_1 ; Select column and row
03C6 D0E0       403            pop acc
03C8 C000       404            push ar0
03CA A834       404            mov r0, CurrentMinute
03CC 1200CC     404            lcall ?Display_BCD
03CF D000       404            pop ar0
03D1 C0E0       405            push acc
03D3 7401       405            mov a, #1
03D5 14         405            dec a
03D6 1200C7     405            lcall ?Set_Cursor_1 ; Select column and row
03D9 D0E0       405            pop acc
03DB C000       406            push ar0
03DD A832       406            mov r0, CurrentHour
03DF 1200CC     406            lcall ?Display_BCD
03E2 D000       406            pop ar0
03E4            407   
03E4 C0E0       408            push acc
03E6 7407       408            mov a, #7
03E8 14         408            dec a
03E9 1200C5     408            lcall ?Set_Cursor_2 ; Select column and row
03EC D0E0       408            pop acc
03EE C000       409            push ar0
03F0 A83D       409            mov r0, AlarmSecond
03F2 1200CC     409            lcall ?Display_BCD
03F5 D000       409            pop ar0
03F7 C0E0       410            push acc
03F9 7404       410            mov a, #4
03FB 14         410            dec a
03FC 1200C5     410            lcall ?Set_Cursor_2 ; Select column and row
03FF D0E0       410            pop acc
0401 C000       411            push ar0
0403 A83B       411            mov r0, AlarmMinute
0405 1200CC     411            lcall ?Display_BCD
0408 D000       411            pop ar0
040A C0E0       412            push acc
040C 7401       412            mov a, #1
040E 14         412            dec a
040F 1200C5     412            lcall ?Set_Cursor_2 ; Select column and row
0412 D0E0       412            pop acc
0414 C000       413            push ar0
0416 A839       413            mov r0, AlarmHour
0418 1200CC     413            lcall ?Display_BCD
041B D000       413            pop ar0
041D            414   
041D E536       415            mov a, CurrentSecond
041F B46054     416       cjne a, #60H, IntermediateLoop ; keep going if you haven't reached 60 yet, otherwise change minute place
0422 E4         417            clr a
0423 F536       418            mov CurrentSecond, a
0425 C0E0       419            push acc
0427 7407       419            mov a, #7
0429 14         419            dec a
042A 1200C7     419            lcall ?Set_Cursor_1 ; Select column and row
042D D0E0       419            pop acc
042F C000       420            push ar0
0431 A836       420            mov r0, CurrentSecond
0433 1200CC     420            lcall ?Display_BCD
0436 D000       420            pop ar0
0438 120190     421            lcall MinuteIncrement
043B            422            ;mov a, CurrentMinute
043B            423            ;mov CurrentSecond, a
043B C0E0       424            push acc
043D 7404       424            mov a, #4
043F 14         424            dec a
0440 1200C7     424            lcall ?Set_Cursor_1 ; Select column and row
0443 D0E0       424            pop acc     ; minutes place
0445 C000       425            push ar0
0447 A834       425            mov r0, CurrentMinute
0449 1200CC     425            lcall ?Display_BCD
044C D000       425            pop ar0
044E E4         426            clr a
044F E534       427            mov a, CurrentMinute
0451 B46022     428            cjne a, #60H, IntermediateLoop ; send to Hour Increment
0454 1201BC     429            lcall HourIncrement 
0457 C0E0       430            push acc
0459 7401       430            mov a, #1
045B 14         430            dec a
045C 1200C7     430            lcall ?Set_Cursor_1 ; Select column and row
045F D0E0       430            pop acc     ; the place in the LCD where we want the BCD counter value
0461 C000       431            push ar0
0463 A832       431            mov r0, CurrentHour
0465 1200CC     431            lcall ?Display_BCD
0468 D000       431            pop ar0 ; This macro is also in 'LCD_4bit.inc'
046A            432   
046A            433   
046A            434   Intermediate_Adjust:
046A C002       435            push AR2
046C 7A32       435            mov R2, #50
046E 12003F     435            lcall ?Wait_Milli_Seconds
0471 D002       435            pop AR2 ; otherwise explodes
0473 0202C9     436       ljmp Button_Interrupt
0476            437   IntermediateLoop:
0476 02029B     438            ljmp loop
0479            439   
0479            440   END
