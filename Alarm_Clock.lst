0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 440 Hz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P3.7 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 24000000 ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 544*2    ; Tone changed to C#
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/(TIMER0_RATE))))
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/(TIMER2_RATE))))
0000             15   
0000             16   ;TODO if time: Add power button
0000             17   AMPM_SET           equ P0.0 ; switch between AM and PM
0000             18   CA_SWITCH     equ P0.1 ; switches buttons between controlling clock and alarm
0000             19   ALARM_OFF     equ P0.3 ; turns off alarm sound
0000             20   SOUND_OUT     equ P2.1
0000             21   SECONDS       equ P2.3 ; adjust seconds
0000             22   MINUTES            equ P2.6 ; adjust minutes
0000             23   HOURS              equ P3.2 ; adjust hours
0000             24   BOOT_BUTTON   equ P3.7
0000             25   
0000             26   ; Reset vector
0000             27   org 0x0000
0000 020271      28       ljmp main
0003             29   
0003             30   ; External interrupt 0 vector (not used in this code)
0003             31   org 0x0003
0003 32          32            reti
0004             33   
0004             34   ; Timer/Counter 0 overflow interrupt vector
000B             35   org 0x000B
000B 02011C      36            ljmp Timer0_ISR
000E             37   
000E             38   ; External interrupt 1 vector (not used in this code)
0013             39   org 0x0013
0013 32          40            reti
0014             41   
0014             42   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             43   org 0x001B
001B 32          44            reti
001C             45   
001C             46   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             47   org 0x0023 
0023 32          48            reti
0024             49            
0024             50   ; Timer/Counter 2 overflow interrupt vector
002B             51   org 0x002B
002B 020145      52            ljmp Timer2_ISR
002E             53   
002E             54   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             55   dseg at 0x30
0030             56   Count1ms:        ds 2 ; Used to determine when half second has passed
0032             57   CurrentHour:     ds 2  
0034             58   CurrentMinute:   ds 2
0036             59   CurrentSecond:   ds 2
0038             60   CurrentAMPM:     ds 1
0039             61   AlarmHour:       ds 2
003B             62   AlarmMinute:     ds 2
003D             63   AlarmSecond:     ds 2
003F             64   AlarmAMPM:       ds 1
0040             65   is_AM:           ds 1
0041             66   is_Alarm_AM:     ds 1
0042             67   is_Alarm_Primed: ds 1
0043             68   is_Clock:        ds 1
0044             69   is_Natural_Increment: ds 1
0045             70   alarm_mask:      ds 1
002E 414D00      71   AM: db 'AM', 0 
0031 504D00      72   PM: db 'PM', 0
0034             73   
0034             74   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0034             75   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             76   bseg
0000             77   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             78   
0034             79   cseg
0034             80   ; These 'equ' must match the wiring between the microcontroller and the LCD!
0034             81   LCD_RS equ P2.0
0034             82   LCD_RW equ P1.7
0034             83   LCD_E  equ P1.6
0034             84   LCD_D4 equ P1.1
0034             85   LCD_D5 equ P1.0
0034             86   LCD_D6 equ P0.7
0034             87   LCD_D7 equ P0.6
                 89   	$LIST
00E2             91   
00E2             92   ;                           1234567890123456    <- This helps determine the location of the counter
00E2 3C2D00      93   Point:                  db '<-', 0 ; hour:minute:second am/pm
00E5 78783A78    94   Initial_Message:        db 'xx:xx:xx xx', 0
     783A7878
     20787800
00F1 202000      95   Clear:                  db '  ', 0
00F4             96   
00F4             97   ;-----------------------------------;
00F4             98   ; Routine to initialize the timer 0 ;
00F4             99   ;-----------------------------------;
00F4            100   Timer0_Init:
00F4 C002       101            push AR2
00F6 7A7F       101            mov R2, #127
00F8 12003F     101            lcall ?Wait_Milli_Seconds
00FB D002       101            pop AR2
00FD C002       102            push AR2
00FF 7A7F       102            mov R2, #127
0101 12003F     102            lcall ?Wait_Milli_Seconds
0104 D002       102            pop AR2
0106 438E04     103            orl CKCON0, #00000100B ; Timer 0 uses the system clock
0109 E589       104            mov a, TMOD
010B 54F0       105            anl a, #0xf0 ; Clear the bits for timer 0
010D 4401       106            orl a, #0x01 ; Configure timer 0 as 16-timer
010F F589       107            mov TMOD, a
0111 758CA9     108            mov TH0, #high(TIMER0_RELOAD)
0114 758AD6     109            mov TL0, #low(TIMER0_RELOAD)
0117            110            ; Enable the timer and interrupts
0117 D2A9       111       setb ET0  ; Enable timer 0 interrupt
0119 D28C       112       setb TR0  ; Start timer 0
011B 22         113            ret
011C            114   
011C            115   ;---------------------------------;
011C            116   ; ISR for timer 0.                ;
011C            117   ;---------------------------------;
011C            118   Timer0_ISR:
011C            119            ;clr TF0  ; According to the data sheet this is done for us already.
011C            120            ; Timer 0 can not autoreload so we need to reload it in the ISR:
011C C28C       121            clr TR0
011E 758CA9     122            mov TH0, #high(TIMER0_RELOAD)
0121 758AD6     123            mov TL0, #low(TIMER0_RELOAD)
0124 D28C       124            setb TR0
0126 B2A1       125            cpl SOUND_OUT ; Toggle the pin connected to the speaker
0128 32         126            reti
0129            127   
0129            128   ;---------------------------------;
0129            129   ; Routine to initialize timer 2   ;
0129            130   ;---------------------------------;
0129            131   Timer2_Init:
0129 438E10     132            orl CKCON0, #0b00010000 ; Timer 2 uses the system clock
012C 75C800     133            mov TMR2CN0, #0 ; Stop timer/counter.  Autoreload mode.
012F 75CFA2     134            mov TMR2H, #high(TIMER2_RELOAD)
0132 75CE40     135            mov TMR2L, #low(TIMER2_RELOAD)
0135            136            ; Set the reload value
0135 75CBA2     137            mov TMR2RLH, #high(TIMER2_RELOAD)
0138 75CA40     138            mov TMR2RLL, #low(TIMER2_RELOAD)
013B            139            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
013B E4         140            clr a
013C F530       141            mov Count1ms+0, a
013E F531       142            mov Count1ms+1, a
0140            143            ; Enable the timer and interrupts
0140 D2AD       144       setb ET2  ; Enable timer 2 interrupt
0142 D2CA       145       setb TR2  ; Enable timer 2
0144 22         146            ret
0145            147   
0145            148   ;---------------------------------;
0145            149   ; ISR for timer 2                 ;
0145            150   ;---------------------------------;
0145            151   Timer2_ISR:
0145 C2CF       152            clr TF2H  ; Timer 2 doesn't clear TF2H automatically. Do it in ISR
0147            153            
0147            154            ; The two registers used in the ISR must be saved in the stack
0147 C0E0       155            push acc
0149 C0D0       156            push psw
014B            157            
014B            158            ; Increment the 16-bit one mili second counter
014B 0530       159            inc Count1ms+0    ; Increment the low 8-bits first
014D E530       160            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
014F 7002       161            jnz Inc_Done
0151 0531       162            inc Count1ms+1
0153            163   
0153            164   Inc_Done:
0153            165            ; Check if half second has passed
0153 E530       166            mov a, Count1ms+0
0155 B4F417     167            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0158 E531       168            mov a, Count1ms+1
015A B40112     169            cjne a, #high(500), Timer2_ISR_done
015D            170            
015D            171            ; 500 milliseconds have passed.  Set a flag so the main program knows
015D D200       172            setb half_seconds_flag ; Let the main program know half second had passed
015F B28C       173            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0161            174            ;setb SOUND_OUT
0161            175            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0161 E4         176            clr a
0162 F530       177            mov Count1ms+0, a
0164 F531       178            mov Count1ms+1, a
0166            179            ; Increment the BCD counter
0166 E536       180            mov a, CurrentSecond
0168            181            ;jnb UPDOWN, Timer2_ISR_decrement
0168 2401       182            add a, #0x01
016A 8000       183            sjmp Timer2_ISR_da
016C            184   ;Timer2_ISR_decrement:
016C            185            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
016C            186   Timer2_ISR_da:
016C D4         187            da a ; Decimal adjust instruction.  Check datasheet for more details!
016D F536       188            mov CurrentSecond, a
016F            189            
016F            190   Timer2_ISR_done:
016F D0D0       191            pop psw
0171 D0E0       192            pop acc
0173 32         193            reti
0174            194   
0174            195   
0174            196   ;---------------------------------;
0174            197   ; Hardware initialization         ;
0174            198   ;---------------------------------;
0174            199   Initialize_All:
0174            200       ; DISABLE WDT: provide Watchdog disable keys
0174 7597DE     201            mov     WDTCN,#0xDE ; First key
0177 7597AD     202            mov     WDTCN,#0xAD ; Second key
017A            203   
017A            204            ; Setup the stack start to the begining of memory only accesible with pointers
017A 75817F     205       mov SP, #7FH
017D            206       
017D            207       ; Enable crossbar and weak pull-ups
017D 75E100     208            mov     XBR0,#0x00
0180 75E200     209            mov     XBR1,#0x00
0183 75E340     210            mov     XBR2,#0x40
0186            211   
0186 75A602     212            mov     P2MDOUT,#0x02 ; make sound output pin (P2.1) push-pull
0189            213            
0189            214            ; Switch clock to 24 MHz
0189 75A900     215            mov     CLKSEL, #0x00 ; 
018C 75A900     216            mov     CLKSEL, #0x00 ; Second write to CLKSEL is required according to the user manual (page 77)
018F            217            
018F            218            ; Wait for 24 MHz clock to stabilze by checking bit DIVRDY in CLKSEL
018F            219   waitclockstable:
018F E5A9       220            mov a, CLKSEL
0191 30E7FB     221            jnb acc.7, waitclockstable 
0194            222   
0194            223            ; Initialize the two timers used in this program
0194 120129     224       lcall Timer2_Init
0197            225   
0197 12008E     226       lcall LCD_4BIT ; Initialize LCD
019A            227       
019A D2AF       228       setb EA   ; Enable Global interrupts
019C            229   
019C 22         230            ret
019D            231   
019D            232   MinuteIncrement:
019D E543       233       mov a, is_Clock
019F B40110     234       cjne a, #1, Alarm_MinuteIncrement ; change Alarm variable instead 
01A2 8000       235       sjmp MinuteIncrement_2
01A4            236   
01A4            237   MinuteIncrement_2:
01A4 E4         238            clr a 
01A5 E534       239            mov a, CurrentMinute
01A7            240            ;jnb UPDOWN, Timer2_ISR_decrement
01A7 2401       241            add a, #0x01
01A9 8000       242            sjmp Timer2_ISR_da_minute
01AB            243   ;Timer2_ISR_decrement:
01AB            244            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
01AB            245   Timer2_ISR_da_minute:
01AB D4         246            da a ; Decimal adjust instruction.  Check datasheet for more details!
01AC F534       247            mov CurrentMinute, a
01AE 754400     248       mov is_Natural_Increment, #0
01B1 22         249            ret
01B2            250   
01B2            251   Alarm_MinuteIncrement:
01B2 E544       252       mov a, is_Natural_Increment
01B4 B400ED     253       cjne a, #0, MinuteIncrement_2 ; if natural increment and alarm set, change the hour
01B7 E4         254       clr a
01B8 E53B       255       mov a, AlarmMinute
01BA 2401       256       add a, #0x01
01BC D4         257       da a
01BD F53B       258       mov AlarmMinute, a
01BF C0E0       259            push acc
01C1 7404       259            mov a, #4
01C3 14         259            dec a
01C4 1200C5     259            lcall ?Set_Cursor_2 ; Select column and row
01C7 D0E0       259            pop acc
01C9 C000       260            push ar0
01CB A83B       260            mov r0, AlarmMinute
01CD 1200CC     260            lcall ?Display_BCD
01D0 D000       260            pop ar0
01D2 754400     261       mov is_Natural_Increment, #0
01D5 22         262       ret
01D6            263   
01D6            264   HourIncrement:
01D6 E543       265       mov a, is_Clock
01D8 B4015E     266       cjne a, #1, Alarm_HourIncrement 
01DB E4         267            clr a 
01DC E532       268            mov a, CurrentHour
01DE B41204     269       cjne a, #12H, am_change ; if it's at 12, next hour should be 1
01E1 7401       270       mov a, #1
01E3 8050       271       sjmp Timer2_ISR_da_hour
01E5            272   am_change:
01E5 B41147     273       cjne a, #11H, Increment_by_1
01E8 E540       274       mov a, is_AM
01EA B40121     275       cjne a, #1, pm_change ; if it's not am
01ED C0E0       276            push acc
01EF 740A       276            mov a, #10
01F1 14         276            dec a
01F2 1200C7     276            lcall ?Set_Cursor_1 ; Select column and row
01F5 D0E0       276            pop acc
01F7            276   
01F7 C083       277            push dph
01F9 C082       277            push dpl
01FB C0E0       277            push acc
01FD 900031     277            mov dptr, #PM
0200 1200BA     277            lcall ?Send_Constant_String
0203 D0E0       277            pop acc
0205 D082       277            pop dpl
0207 D083       277            pop dph
0209 754000     278       mov is_AM, #0
020C 8021       279       sjmp Increment_By_1
020E            280   pm_change:
020E C0E0       281            push acc
0210 740A       281            mov a, #10
0212 14         281            dec a
0213 1200C7     281            lcall ?Set_Cursor_1 ; Select column and row
0216 D0E0       281            pop acc
0218            281   
0218 C083       282            push dph
021A C082       282            push dpl
021C C0E0       282            push acc
021E 90002E     282            mov dptr, #AM
0221 1200BA     282            lcall ?Send_Constant_String
0224 D0E0       282            pop acc
0226 D082       282            pop dpl
0228 D083       282            pop dph
022A 754001     283       mov is_AM, #1
022D 8000       284       sjmp Increment_By_1
022F            285   Increment_by_1:
022F E532       286       mov a, CurrentHour
0231 2401       287            add a, #0x01
0233 8000       288            sjmp Timer2_ISR_da_hour
0235            289   ;Timer2_ISR_decrement:
0235            290            ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0235            291   Timer2_ISR_da_hour:
0235 D4         292            da a ; Decimal adjust instruction.  Check datasheet for more details!
0236 F532       293            mov CurrentHour, a
0238 22         294            ret
0239            295   
0239            296   Alarm_HourIncrement:
0239 E4         297       clr a
023A E539       298       mov a, AlarmHour
023C B41219     299       cjne a, #12H, Increment_alarm_by_1
023F 7401       300       mov a, #1
0241 D4         301       da a
0242 F539       302       mov AlarmHour, a
0244 C0E0       303            push acc
0246 7401       303            mov a, #1
0248 14         303            dec a
0249 1200C5     303            lcall ?Set_Cursor_2 ; Select column and row
024C D0E0       303            pop acc
024E C000       304            push ar0
0250 A839       304            mov r0, AlarmHour
0252 1200CC     304            lcall ?Display_BCD
0255 D000       304            pop ar0
0257 22         305       ret
0258            306   Increment_alarm_by_1:
0258 2401       307       add a, #0x01
025A D4         308       da a
025B F539       309       mov AlarmHour, a
025D C0E0       310            push acc
025F 7401       310            mov a, #1
0261 14         310            dec a
0262 1200C5     310            lcall ?Set_Cursor_2 ; Select column and row
0265 D0E0       310            pop acc
0267 C000       311            push ar0
0269 A839       311            mov r0, AlarmHour
026B 1200CC     311            lcall ?Display_BCD
026E D000       311            pop ar0
0270 22         312       ret
0271            313   ;---------------------------------;
0271            314   ; Main program.                   ;
0271            315   ;---------------------------------;
0271            316   main:
0271 120174     317       lcall Initialize_All
0274 020277     318       ljmp setup
0277            319   
0277            320   setup:
0277 753212     321       mov CurrentHour, #0x12
027A 753400     322       mov CurrentMinute, #0x00
027D 753600     323       mov CurrentSecond, #0x00
0280 753912     324       mov AlarmHour, #0x12
0283 753B00     325       mov AlarmMinute, #0x00
0286 753D00     326       mov AlarmSecond, #0x00
0289 02028C     327       ljmp main_2
028C            328   
028C            329   main_2:
028C            330   
028C            331            
028C            332       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
028C            333       
028C C0E0       334            push acc
028E 7401       334            mov a, #1
0290 14         334            dec a
0291 1200C7     334            lcall ?Set_Cursor_1 ; Select column and row
0294 D0E0       334            pop acc
0296 C083       335            push dph
0298 C082       335            push dpl
029A C0E0       335            push acc
029C 9000E5     335            mov dptr, #Initial_Message
029F 1200BA     335            lcall ?Send_Constant_String
02A2 D0E0       335            pop acc
02A4 D082       335            pop dpl
02A6 D083       335            pop dph
02A8 C0E0       336            push acc
02AA 740F       336            mov a, #15
02AC 14         336            dec a
02AD 1200C7     336            lcall ?Set_Cursor_1 ; Select column and row
02B0 D0E0       336            pop acc
02B2 C083       337            push dph
02B4 C082       337            push dpl
02B6 C0E0       337            push acc
02B8 9000E2     337            mov dptr, #Point
02BB 1200BA     337            lcall ?Send_Constant_String
02BE D0E0       337            pop acc
02C0 D082       337            pop dpl
02C2 D083       337            pop dph
02C4 C0E0       338            push acc
02C6 7401       338            mov a, #1
02C8 14         338            dec a
02C9 1200C5     338            lcall ?Set_Cursor_2 ; Select column and row
02CC D0E0       338            pop acc
02CE C083       339            push dph
02D0 C082       339            push dpl
02D2 C0E0       339            push acc
02D4 9000E5     339            mov dptr, #Initial_Message
02D7 1200BA     339            lcall ?Send_Constant_String
02DA D0E0       339            pop acc
02DC D082       339            pop dpl
02DE D083       339            pop dph
02E0 C0E0       340            push acc
02E2 740A       340            mov a, #10
02E4 14         340            dec a
02E5 1200C7     340            lcall ?Set_Cursor_1 ; Select column and row
02E8 D0E0       340            pop acc
02EA            341   
02EA D200       342       setb half_seconds_flag
02EC 754200     343       mov is_Alarm_Primed, #0x0 ; this way, the alarm wont immediately go off when power is on
02EF 754500     344       mov alarm_mask, #0x0
02F2            345            
02F2            346   
02F2 C0E0       347            push acc
02F4 740A       347            mov a, #10
02F6 14         347            dec a
02F7 1200C7     347            lcall ?Set_Cursor_1 ; Select column and row
02FA D0E0       347            pop acc
02FC C083       348            push dph
02FE C082       348            push dpl
0300 C0E0       348            push acc
0302 90002E     348            mov dptr, #AM
0305 1200BA     348            lcall ?Send_Constant_String
0308 D0E0       348            pop acc
030A D082       348            pop dpl
030C D083       348            pop dph ; intialise with AM
030E            349   
030E C0E0       350            push acc
0310 740A       350            mov a, #10
0312 14         350            dec a
0313 1200C5     350            lcall ?Set_Cursor_2 ; Select column and row
0316 D0E0       350            pop acc
0318            350   
0318 C083       351            push dph
031A C082       351            push dpl
031C C0E0       351            push acc
031E 90002E     351            mov dptr, #AM
0321 1200BA     351            lcall ?Send_Constant_String
0324 D0E0       351            pop acc
0326 D082       351            pop dpl
0328 D083       351            pop dph ; intialise with AM
032A 754001     352            mov is_AM, #1
032D 754101     353       mov is_Alarm_AM, #1
0330 754301     354       mov is_Clock, #1 ; as opposed to Alarm mode
0333 754400     355       mov is_Natural_Increment, #0
0336            356   
0336            357   
0336            358            ; After initialization the program stays in this 'forever' loop
0336            359   loop:
0336 20B761     360            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
0339 C002       361            push AR2
033B 7A32       361            mov R2, #50
033D 12003F     361            lcall ?Wait_Milli_Seconds
0340 D002       361            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0342 20B755     362            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
0345 30B7FD     363            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
0348            364            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
0348            365            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
0348 C2CA       366            clr TR2                 ; Stop timer 2
034A C28C       367       clr TR0
034C C2A1       368       clr SOUND_OUT
034E            369       ; check to see if alarm is hit
034E E4         370            clr a
034F F530       371            mov Count1ms+0, a
0351 F531       372            mov Count1ms+1, a
0353            373            ; Now clear the BCD counter
0353            374            ;mov CurrentHour, a
0353            375       ;mov CurrentMinute, a
0353 F536       376       mov CurrentSecond, a
0355 D2CA       377            setb TR2                ; Start timer 2
0357            378   
0357 E532       379       mov a, CurrentHour
0359 B41241     380       cjne a, #12H, Button_Interrupt
035C 020451     381       ljmp AMPM_Display
035F 02039D     382            ljmp Button_Interrupt           
0362            383   
0362            384   Alarm:
0362            385       ;mov a, alarm_mask
0362            386       ;cjne a, #0, to_loop_b ; if mask is on, skip
0362            387       ;clr a
0362            388       ;mov a, #1
0362            389       ;mov alarm_mask,
0362 E532       390       mov a, CurrentHour
0364 B53915     391       cjne a, AlarmHour, to_main_4
0367 E534       392       mov a, CurrentMinute
0369 B53B10     393       cjne a, AlarmMinute, to_main_4
036C E540       394       mov a, is_AM
036E B5410B     395       cjne a, is_Alarm_AM, to_main_4
0371 E545       396       mov a, alarm_mask
0373 B40006     397       cjne a, #0, to_main_4
0376 1200F4     398       lcall Timer0_Init
0379            399       ;mov is_Alarm_Primed, #0
0379 020568     400       ljmp main_4
037C            401   
037C            402   to_main_4:
037C 020568     403       ljmp main_4
037F            404   
037F            405   to_loop_b:
037F 0204EB     406       ljmp loop_b
0382            407   
0382            408   Add_Hour:
0382 1201D6     409       lcall HourIncrement
0385 0204EB     410       ljmp loop_b
0388            411   
0388            412   Add_Minute:
0388 E4         413       clr a
0389 E534       414       mov a, CurrentMinute
038B B45906     415       cjne a, #59H, Go_to_minute_increment
038E E4         416       clr a
038F F534       417       mov CurrentMinute, a
0391 0204EB     418       ljmp loop_b
0394            419   
0394            420   Go_to_minute_increment:
0394 12019D     421       lcall MinuteIncrement
0397 0204EB     422       ljmp loop_b
039A            423   
039A            424   loop_a:
039A 300099     425            jnb half_seconds_flag, loop
039D            426   
039D            427   Button_Interrupt:
039D 308315     428       jnb ALARM_OFF, turn_alarm_off
03A0 30B2DF     429       jnb HOURS, Add_Hour
03A3 30A6E2     430       jnb MINUTES, Add_Minute
03A6 30A38D     431       jnb SECONDS, loop
03A9 30811E     432       jnb CA_SWITCH, SWITCH
03AC 208003     433            jb AMPM_SET, Send_to_Loop_B
03AF            434       ;Wait_Milli_Seconds(#50) ; not really necessary here
03AF            435       ;jb AMPM_SET, loop_b
03AF 30805E     436            jnb AMPM_SET, to_AMPM_display ; otherwise, continue
03B2            437   
03B2            438   Send_to_Loop_B:
03B2 0204EB     439       ljmp loop_b
03B5            440   
03B5            441   turn_alarm_off:
03B5 E542       442       mov a, is_Alarm_Primed
03B7 B401F8     443       cjne a, #1, Send_to_Loop_B
03BA C28C       444       clr tr0
03BC C2A1       445       clr SOUND_OUT
03BE E4         446       clr a
03BF 7401       447       mov a, #1
03C1 F545       448       mov alarm_mask, a
03C3 7400       449       mov a, #0
03C5 F542       450       mov is_Alarm_Primed, a
03C7 0204EB     451       ljmp loop_b
03CA            452   
03CA            453   SWITCH:
03CA E543       454       mov a, is_Clock
03CC B40044     455       cjne a, #0, Alarm_Mode
03CF C0E0       456            push acc
03D1 740F       456            mov a, #15
03D3 14         456            dec a
03D4 1200C7     456            lcall ?Set_Cursor_1 ; Select column and row
03D7 D0E0       456            pop acc
03D9            456   
03D9 C083       457            push dph
03DB C082       457            push dpl
03DD C0E0       457            push acc
03DF 9000E2     457            mov dptr, #Point
03E2 1200BA     457            lcall ?Send_Constant_String
03E5 D0E0       457            pop acc
03E7 D082       457            pop dpl
03E9 D083       457            pop dph
03EB C0E0       458            push acc
03ED 740F       458            mov a, #15
03EF 14         458            dec a
03F0 1200C5     458            lcall ?Set_Cursor_2 ; Select column and row
03F3 D0E0       458            pop acc
03F5 C083       459            push dph
03F7 C082       459            push dpl
03F9 C0E0       459            push acc
03FB 9000F1     459            mov dptr, #Clear
03FE 1200BA     459            lcall ?Send_Constant_String
0401 D0E0       459            pop acc
0403 D082       459            pop dpl
0405 D083       459            pop dph
0407 754301     460       mov is_Clock, #1
040A 754201     461       mov is_Alarm_Primed, #1  ; now that it's pressed at least once, prime the alarm
040D 0204EB     462       ljmp loop_b
0410            463   
0410            464   to_AMPM_display:
0410 020451     465       ljmp AMPM_Display
0413            466   
0413            467   Alarm_Mode:
0413 C0E0       468            push acc
0415 740F       468            mov a, #15
0417 14         468            dec a
0418 1200C7     468            lcall ?Set_Cursor_1 ; Select column and row
041B D0E0       468            pop acc
041D C083       469            push dph
041F C082       469            push dpl
0421 C0E0       469            push acc
0423 9000F1     469            mov dptr, #Clear
0426 1200BA     469            lcall ?Send_Constant_String
0429 D0E0       469            pop acc
042B D082       469            pop dpl
042D D083       469            pop dph
042F C0E0       470            push acc
0431 740F       470            mov a, #15
0433 14         470            dec a
0434 1200C5     470            lcall ?Set_Cursor_2 ; Select column and row
0437 D0E0       470            pop acc
0439 C083       471            push dph
043B C082       471            push dpl
043D C0E0       471            push acc
043F 9000E2     471            mov dptr, #Point
0442 1200BA     471            lcall ?Send_Constant_String
0445 D0E0       471            pop acc
0447 D082       471            pop dpl
0449 D083       471            pop dph
044B 754300     472       mov is_Clock, #0
044E 0204EB     473       ljmp loop_b
0451            474   
0451            475   AMPM_Display:
0451 E543       476       mov a, is_Clock
0453 B40149     477       cjne a, #1, Alarm_AMPM
0456 E540       478            mov a, is_AM
0458 B40022     479            cjne a, #0, Display_PM ; if button is pressed and the flag is currently AM, set to PM
045B C0E0       480            push acc
045D 740A       480            mov a, #10
045F 14         480            dec a
0460 1200C7     480            lcall ?Set_Cursor_1 ; Select column and row
0463 D0E0       480            pop acc
0465 C083       481            push dph
0467 C082       481            push dpl
0469 C0E0       481            push acc
046B 90002E     481            mov dptr, #AM
046E 1200BA     481            lcall ?Send_Constant_String
0471 D0E0       481            pop acc
0473 D082       481            pop dpl
0475 D083       481            pop dph
0477            482            ;cpl AMPM_SET
0477 754001     483            mov is_AM, #1
047A            484            ;clr a
047A 0204EB     485            ljmp loop_b
047D            486            
047D            487   
047D            488   Display_PM:
047D C0E0       489            push acc
047F 740A       489            mov a, #10
0481 14         489            dec a
0482 1200C7     489            lcall ?Set_Cursor_1 ; Select column and row
0485 D0E0       489            pop acc
0487            489   
0487 C083       490            push dph
0489 C082       490            push dpl
048B C0E0       490            push acc
048D 900031     490            mov dptr, #PM
0490 1200BA     490            lcall ?Send_Constant_String
0493 D0E0       490            pop acc
0495 D082       490            pop dpl
0497 D083       490            pop dph
0499            491            ;cpl AMPM_SET   
0499 754000     492            mov is_AM, #0
049C            493            ;clr a
049C 0204EB     494            ljmp loop_b
049F            495   
049F            496   Alarm_AMPM:
049F E541       497       mov a, is_Alarm_AM
04A1 B40022     498       cjne a, #0, Display_Alarm_PM ; if button is pressed and the flag is currently AM, set to PM
04A4 C0E0       499            push acc
04A6 740A       499            mov a, #10
04A8 14         499            dec a
04A9 1200C5     499            lcall ?Set_Cursor_2 ; Select column and row
04AC D0E0       499            pop acc
04AE            499   
04AE C083       500            push dph
04B0 C082       500            push dpl
04B2 C0E0       500            push acc
04B4 90002E     500            mov dptr, #AM
04B7 1200BA     500            lcall ?Send_Constant_String
04BA D0E0       500            pop acc
04BC D082       500            pop dpl
04BE D083       500            pop dph
04C0            501            ;cpl AMPM_SET
04C0 754101     502            mov is_Alarm_AM, #1
04C3            503            ;clr a
04C3 0204EB     504            ljmp loop_b
04C6            505            
04C6            506   
04C6            507   Display_Alarm_PM:
04C6 C0E0       508            push acc
04C8 740A       508            mov a, #10
04CA 14         508            dec a
04CB 1200C5     508            lcall ?Set_Cursor_2 ; Select column and row
04CE D0E0       508            pop acc
04D0            508   
04D0 C083       509            push dph
04D2 C082       509            push dpl
04D4 C0E0       509            push acc
04D6 900031     509            mov dptr, #PM
04D9 1200BA     509            lcall ?Send_Constant_String
04DC D0E0       509            pop acc
04DE D082       509            pop dpl
04E0 D083       509            pop dph
04E2            510            ;cpl AMPM_SET   
04E2 754100     511            mov is_Alarm_AM, #0
04E5            512            ;clr a
04E5 0204EB     513            ljmp loop_b
04E8            514   
04E8            515   to_Alarm:
04E8 020362     516       ljmp Alarm
04EB            517   
04EB            518   loop_b:
04EB            519            ;displaying block
04EB C200       520       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
04ED            521            ;Set_Cursor(1, 10)
04ED            522            ;Display_BCD(AM)
04ED C0E0       523            push acc
04EF 7407       523            mov a, #7
04F1 14         523            dec a
04F2 1200C7     523            lcall ?Set_Cursor_1 ; Select column and row
04F5 D0E0       523            pop acc
04F7 C000       524            push ar0
04F9 A836       524            mov r0, CurrentSecond
04FB 1200CC     524            lcall ?Display_BCD
04FE D000       524            pop ar0
0500 C0E0       525            push acc
0502 7404       525            mov a, #4
0504 14         525            dec a
0505 1200C7     525            lcall ?Set_Cursor_1 ; Select column and row
0508 D0E0       525            pop acc
050A C000       526            push ar0
050C A834       526            mov r0, CurrentMinute
050E 1200CC     526            lcall ?Display_BCD
0511 D000       526            pop ar0
0513 C0E0       527            push acc
0515 7401       527            mov a, #1
0517 14         527            dec a
0518 1200C7     527            lcall ?Set_Cursor_1 ; Select column and row
051B D0E0       527            pop acc
051D C000       528            push ar0
051F A832       528            mov r0, CurrentHour
0521 1200CC     528            lcall ?Display_BCD
0524 D000       528            pop ar0
0526            529   
0526 C0E0       530            push acc
0528 7407       530            mov a, #7
052A 14         530            dec a
052B 1200C5     530            lcall ?Set_Cursor_2 ; Select column and row
052E D0E0       530            pop acc
0530 C000       531            push ar0
0532 A83D       531            mov r0, AlarmSecond
0534 1200CC     531            lcall ?Display_BCD
0537 D000       531            pop ar0
0539 C0E0       532            push acc
053B 7404       532            mov a, #4
053D 14         532            dec a
053E 1200C5     532            lcall ?Set_Cursor_2 ; Select column and row
0541 D0E0       532            pop acc
0543 C000       533            push ar0
0545 A83B       533            mov r0, AlarmMinute
0547 1200CC     533            lcall ?Display_BCD
054A D000       533            pop ar0
054C C0E0       534            push acc
054E 7401       534            mov a, #1
0550 14         534            dec a
0551 1200C5     534            lcall ?Set_Cursor_2 ; Select column and row
0554 D0E0       534            pop acc
0556 C000       535            push ar0
0558 A839       535            mov r0, AlarmHour
055A 1200CC     535            lcall ?Display_BCD
055D D000       535            pop ar0
055F            536   
055F C28C       537       clr tr0
0561            538       
0561 E542       539       mov a, is_Alarm_Primed
0563 B40082     540       cjne a, #0H, to_Alarm
0566 8000       541       sjmp main_4
0568            542   
0568            543   main_4:
0568 754400     544       mov is_Natural_Increment, #0
056B            545   
056B E536       546            mov a, CurrentSecond
056D B4606D     547       cjne a, #60H, IntermediateLoop ; keep going if you haven't reached 60 yet, otherwise change minute place
0570 E4         548            clr a
0571 F536       549            mov CurrentSecond, a
0573 C0E0       550            push acc
0575 7407       550            mov a, #7
0577 14         550            dec a
0578 1200C7     550            lcall ?Set_Cursor_1 ; Select column and row
057B D0E0       550            pop acc
057D C000       551            push ar0
057F A836       551            mov r0, CurrentSecond
0581 1200CC     551            lcall ?Display_BCD
0584 D000       551            pop ar0
0586 754401     552       mov is_Natural_Increment, #1
0589 12019D     553            lcall MinuteIncrement
058C            554            ;mov a, CurrentMinute
058C            555            ;mov CurrentSecond, a
058C C0E0       556            push acc
058E 7404       556            mov a, #4
0590 14         556            dec a
0591 1200C7     556            lcall ?Set_Cursor_1 ; Select column and row
0594 D0E0       556            pop acc     ; minutes place
0596 C000       557            push ar0
0598 A834       557            mov r0, CurrentMinute
059A 1200CC     557            lcall ?Display_BCD
059D D000       557            pop ar0
059F E4         558            clr a
05A0 E534       559            mov a, CurrentMinute
05A2 B46038     560            cjne a, #60H, IntermediateLoop ; send to Hour Increment
05A5 E4         561       clr a
05A6 F534       562       mov CurrentMinute, a
05A8 C0E0       563            push acc
05AA 7404       563            mov a, #4
05AC 14         563            dec a
05AD 1200C7     563            lcall ?Set_Cursor_1 ; Select column and row
05B0 D0E0       563            pop acc
05B2 C000       564            push ar0
05B4 A834       564            mov r0, CurrentMinute
05B6 1200CC     564            lcall ?Display_BCD
05B9 D000       564            pop ar0
05BB 1201D6     565            lcall HourIncrement 
05BE C0E0       566            push acc
05C0 7401       566            mov a, #1
05C2 14         566            dec a
05C3 1200C7     566            lcall ?Set_Cursor_1 ; Select column and row
05C6 D0E0       566            pop acc     ; the place in the LCD where we want the BCD counter value
05C8 C000       567            push ar0
05CA A832       567            mov r0, CurrentHour
05CC 1200CC     567            lcall ?Display_BCD
05CF D000       567            pop ar0 ; This macro is also in 'LCD_4bit.inc'
05D1            568   
05D1            569   
05D1            570   Intermediate_Adjust:
05D1 C002       571            push AR2
05D3 7A32       571            mov R2, #50
05D5 12003F     571            lcall ?Wait_Milli_Seconds
05D8 D002       571            pop AR2 ; otherwise explodes
05DA 02039D     572       ljmp Button_Interrupt
05DD            573   IntermediateLoop:
05DD 020336     574            ljmp loop
05E0            575   
05E0            576   END
